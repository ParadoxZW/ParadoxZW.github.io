[{"title":"HTML基础","url":"/2018/03/21/HTML%E5%9F%BA%E7%A1%80/","content":"HTML基础语言简介HTML（Hypertext Markup Language, 超文本标记语言)，说白了就是网页的源码，包含、描述了网页中将要展示的文本、图片等信息，同时浏览器可以理解为这种格式的代码的编译器。因此HTML是学习网页设计要掌握的最基础知识（后续要掌握的知识有CSS、JavaScript）。本文旨在记录一些基础的语法，或者说元素。\n基础知识如果你打开一个网页，然后点选浏览器选项中的查看源码，那就会看到一坨带有&lt;xxx&gt;这种类似符号的代码，这种记号称之为tags，用来组织网页信息。&lt;xxx yy=&quot;zz&quot;&gt; yy是xxx tag的一个属性（attributes），用来增加一些额外的信息，比如tags所包含文字的字体；“zz”是属性值，例如zz是字体名称。只有“true”和“false”两个值的属性（称为Boolean attributes）在只写属性名的时候默认值为true，不写该属性，其值默认为false。\n基本tags&lt;html&gt;&lt;/html&gt; 表示html的开始和结束，也就是所有代码都要放在这两个tags中间。&lt;html lang=&quot;en-GB&quot;&gt;lang属性表示网页的语言。\n&lt;head&gt;&lt;/head&gt; 包含head section，其中的内容不在页面直接显示\n&lt;title&gt;&lt;/title&gt; 在head section中，包含浏览器打开网页时的标签页名\n&lt;body&gt;&lt;/body&gt; 包含body section，其中的内容在网页中直接显示\n&lt;!DOCTYPE html&gt; 一般写在文档的最前面，用来告诉浏览器所用的代码版本是HTML5\n&lt;h1&gt;&lt;/h1&gt;、&lt;h2&gt;&lt;/h2&gt; 包含标题，按数字分层\n&lt;p&gt;&lt;/p&gt; 包含一个段落\n&lt;br&gt; 换行符。这个tag不像上面几个那样是成对的，因为它不需要包含内容，这样的tag叫empty tag\n&lt;em&gt;&lt;/em&gt; 被其包含的文字会显示斜体\n&lt;strong&gt;&lt;/strong&gt; 被其包含的文字会显示粗体\n&lt;hr&gt; 分割线\n&lt;!--F**K THE WIRLD--&gt; 这个是注释\n超链接（hyperlinks）与多媒体&lt;a&gt;&lt;/a&gt; 其中的文字或图片等会变成超链接。&lt;a href=&quot;https://*****&quot; target=&quot;_blank&quot;&gt; href属性为超链接所指路径或网址;target属性为打开新网页的方式，属性值“_blank”打开新标签页\n&lt;img src=&quot;&quot; width=&quot;200&quot; hight=&quot;135&quot; alt=&quot;oops!&quot;&gt; 图片。src属性为图片的地址;alt为图片路径失效时显示的图片。通过tags的嵌套&lt;a&gt;&lt;img&gt;&lt;/a&gt;可以实现将图片变成超链接\n&lt;iframe&gt;&lt;/iframe&gt; inline frame,网页中的一个子网页或者说框架，利用YouTube可以实现视频的插入 &lt;iframe width=&quot;200&quot; hight=&quot;135&quot; src=&quot;https://www.youtube.com/embed/****&quot;&gt;&lt;/iframe&gt;\n&lt;video src=&quot;&quot; controls=&quot;true&quot;&gt; 插入视频的另一种方式。这里src是视频文件的地址；control为“true”时显示视频的播放和暂停按钮\n&lt;audio&gt; 插入音频。用法与video类似\n列表（list）与表格（table）&lt;ol&gt;&lt;/ol&gt; 有序号的列表。type属性表示编号的类型，如默认为1.2.3.,值“A”表示按A.B.C.排列，其他属性值还有“a”，希腊字母“I”等；属性reversed表示是否编号按降序排列，是一个Boolean attributes\n&lt;ul&gt;&lt;/ul&gt; 没有序号的列表\n&lt;li&gt;&lt;/li&gt; 列表中的一项。嵌在ol或ul中\n&lt;table&gt;&lt;/table&gt; 有行和列的表格。border属性值有“1”和“0”，表示是否加边框\n&lt;tr&gt;&lt;/tr&gt; 表格中的一行。嵌在table tags中\n&lt;td&gt;&lt;/td&gt; 一行中的一格。嵌在tr tags中\n&lt;th&gt;&lt;/th&gt; 表头所占的一格。通常嵌在第一组tr中。属性colspan表示在这个标题下拆分多少列\n###风格（style）基本所有的tags（或者称为HTML element）都有一个style属性，用来设定大小、颜色等等，以达到美好效果，如&lt;body style=&quot;background_color:gray&quot;&gt;可以设定网页背景色。style的值称为style declaration，是用CSS格式写的。CSS是一种用来设计网页显示效果的语言，格式是property:value;，这里value是多个单词时，用单引号括起来。property除了背景颜色，还有文字颜色color、字体font-family、字体大小font-size(值为像素px或百分比%)、文字位置text-align（如值center使文字居中）可以用&lt;div&gt;&lt;/div&gt;将代码块括起来，相当于在网页中圈了一块区域（section），然后用style属性对这块区域进行设计。而&lt;span&gt;&lt;/span&gt;可以用来截取文字中的一部分进行style\n","tags":["html"]},{"title":"N维随机游走的常返性模拟实验验证","url":"/2021/08/09/N%E7%BB%B4%E9%9A%8F%E6%9C%BA%E6%B8%B8%E8%B5%B0%E7%9A%84%E5%B8%B8%E8%BF%94%E6%80%A7%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E9%AA%8C%E9%AA%8C%E8%AF%81/","content":"引子最近痴迷于用Python进行各种随机实验（概率与统计真的太好玩了），甚至尝试用一些蒙特卡洛和数值模拟的方法验证一些数学Theorem。本文将记录我对随机游走定理的实验验证。\n先简单介绍一下这个定理。随机游走定理指出，在一维或二维空间中，从起始点出发进行随机运动的点会无限次回到起始点，也就是具有“常返性”；而在大于等于三维的空间中，随机运动的点不具有“常返性”。不具有常返性，不是指不会回来，而是每回来一次，再次回来的概率就会越来越小，直至趋于0。直观上看，就是这个点在回到起始点若干次（也有可能一次都没有）之后，它再也不会回来，而是往原理起始点的方向“扩散”开去。\n匈牙利数学家P´olya在1921年证明了该定理，所以这个定理有时候被称为P´olya’s Random Walk Theorem或Po´lya’s Recurrence Theorem。日本著名数学家角谷静夫通俗形象地将Po´lya随机游走定理表述为：喝醉的酒鬼总能找到回家的路，但是喝醉的鸟不能。虽然这个描述有失准确，但是深入人心，因此也有人称该定理为“酒鬼回家定理”。我在阅读了随机游走定理的一个证明1之后，萌生了通过Python进行模拟实验验证的想法。本文记录了验证的方法和实验结果。\n模型建立随机游走问题的深入分析我们首先需要建立一个可以准确表述和分析随机游走定理的数学模型。在一个N维空间中有一个点，称其为“粒子”（仅仅只是数学上的点），不妨设这个点的起始坐标为（有N个点），即坐标系的原点。粒子从原点出发进行随机的运动，具体来说，每次往随机一个坐标轴的方向或反方向移动一个单位的距离。在一维空间中，就是随机往左或往右走一步（每一步都是一样长的），在二维空间中就是上下左右四个方向选一个走。上述这种离散的随机运动模式可以简单地概括为“N维晶格上的随机游走”，因为粒子的每个可能位置是离散的，把相邻的点连接起来（注意这些连线其实就是粒子可能行走路径），就形成了一个类似晶格的空间。\n\n随机游走定理的一个前提是，粒子具有无限长的运动时间，也就是粒子可以移动无限步。随机游走定理指出，在一维和二维晶格中，粒子出发后会以100%的概率回到原点，然后再次离开，那么根据随机游走定理，它一定会第二次回来……它会无限次回到原点。而在大于等于三维的空间中，随机游走的点回到原点的概率小于1。假设粒子出发后第一次回到原点的概率是，那么第二次回来的概率就是。这个概率随着回归次数（粒子回到原点的次数）的增加而指数衰减。所以对于N（）维的情况，粒子回到原点的次数有一个有限的期望。\n假设我们能进行N维晶格上随机游走的实验，能够观察无限长的时间并记录粒子的回归次数。而且我们可以进行无限次独立的实验观测。对这无限次观测的结果求平均（其实就得到了期望），我们会发现在一维和二维空间中，回归次数是无限大，而在大于等于三维的空间中回归次数的平均值是一个有限的正实数。当然我们不可能实现这样的理想实验，因为这里有两个“无限”，但是我们可以用较长的时间和较大量的实验次数去近似理想实验。并且从实验结果中观察到“趋于无穷”或“收敛于有限”的趋势。\n有限的模型在计算机中，很容易实现一个有限步随机游走的模拟实验。把N维晶格中的粒子抽象成一个整数数组，这个数组代表了粒子的坐标。每次移动就是对数组中的随机一个数加1或减1。在每次实验中让坐标从原点开始“移动”步，并且进行次这样的实验。其中和会设为一个较大的整数。\n一个较困难的问题是，要对这样的模拟实验进行怎样的统计，并从统计结果中观察出随机游走定理的结论。如果直接统计回归次数并取平均，那么存在一个问题，随着实验次数的增加，我们得到的平均值其实是在接近步内的回归次数的期望，而不是上一小节所述的理论上的回归次数期望，所以无论是几维的随机游走，我们得到的期望都会是一个有限的数值，而且从这个数值结果中难以观察到什么趋势。综上，在有限的实验中，步内的回归次数并不是一个很好的统计量。\n于是我设计了这样一个统计量，对一次有限随机游走实验，统计一个数值序列，是中的第个元素，它的值等于本次实验中前步内，粒子回到原点的次数。所以是一个有个元素的数值序列，它记录了一次实验中，随着时间的推移，回归次数的增长情况。我们对次实验得到的序列的个样本求平均得到，然后画出的曲线（纵轴表示元素的值，横轴表示元素的序号）。这个曲线描述了（前步内的回归次数）的均值随（时间）的变化情况。在足够大的情况下，将会非常接近前步内的回归次数的期望随时间变化的曲线，至少已经能体现出它的变化趋势了。我们期望得到的结果是，在一维和二维情况下，我们能观察到一个发散的曲线（无上界），而在三维及更高维度的情况，我们能看到一个收敛的曲线（有上界）。\n实验首先给出实验的代码\nimport numpy as npimport randomdef random_walk(N, T=10000):    \"\"\"        @N: 晶格空间的维数        @T: 实验步数    \"\"\"    p = np.zeros((N, ))    origin = np.zeros((N, ))    moves = [1, -1]    dims = [*range(N)]    count = 0    A = []    for i in range(T):        move = random.choice(moves)        dim = random.choice(dims)        p[dim] += move        if (p == origin).all():            count += 1        A.append(count)    return np.array(A)M = int(1e4) # 重复实验次数A_sum = 0for i in range(M):    A_sum += random_walk(1) # 进行一维情况下的实验A_bar = A_sum / M\n上述代码省略了画图的部分，并只展示了一维情况下的实验。对一二三维情况下的统计情况的可视化如下（因为只要证明了三维是收敛的，四维就是同理可得了，所以我没有做更高维度的实验）\n\n可以看到一维情况下，曲线明显是发散的。但是肉眼难以判断二维和三维的曲线变化趋势。我把二维和三维的曲线图单独拉出来对比如下\n\n二维的曲线增长接近对数曲线，即二维的是类似这样的曲线，因此是发散的；而三维的曲线明显保持平坦的模式，所以可以判断它应该是收敛的，而且从图可知三维随机游走运动的回归次数的期望应该在0.5左右。\n上述实验分析验证了我们的猜想。\n总结本文通过模拟实验验证了P´olya随机游走定理，和理论证明相比，实验验证的优势是直观易懂，无需高等的数学知识和技巧，而且能估计得到大于等于三维情况下的回归次数期望的数值结果。\n参考\n[1] 喝醉的酒鬼能找到回家的路吗？\n[2] 理论证明\n\n","tags":["mathematical puzzel","概率与统计"]},{"title":"Notes: RETHINKING ARCHITECTURE SELECTION IN DIFFERENTIABLE NAS","url":"/2021/09/14/Rethinking%20gradient-based%20nas/","content":"简介提出DARTS中的并不能很好的反应operator的strength。因此设计了基于扰动的评价指标来选择operator，在实现上只需要修改DARTS的operator选择阶段（即离散化阶段）。实验证明这个方法不仅能一致提升DARTS类方法的表现，而且能解决DARTS的鲁棒性差的问题。\n方法在darts的supernet训练好之后，进行perturbation-based architecture selection(PT)，包括两点：\n\n去掉一个operator，用accuracy下降的大小来作为operator选择的依据\n逐步离散化edge，每确定一个edge上的operator就fintune一次具体如下\n\n实验与结论进行了如下实验：\n\nComparison with state-of-the-art image classifiers on CIFAR-10. 在现有的DARTS类方法上加上了PT，分数都得到了提升。\nRobustness issue of DARTS can be explained by the failure ofmagnitude-based architecture selection. 实验验证了DARTS在某些搜索空间中失效的现象可以通过PT避免\ntest a baseline by combining progressive tuning with magnitude-based operation selection instead of our selection criterion。证明论文提出的评价指标确实更好体现了operator的strength。\n实验证明了在supernet的训练过程中可以固定为0（即去掉），使用PT后性能没有下降\n\n","tags":["深度学习","NAS","阅读笔记"]},{"title":"Rust+VSCode从build到debug原创配置","url":"/2018/07/16/Rust-VSCode%E4%BB%8Ebuild%E5%88%B0debug%E5%8E%9F%E5%88%9B%E9%85%8D%E7%BD%AE/","content":"前言搞了整整一天的rust+vscode的开发环境，因为rust太新了，再加上Windows用户往往只是开发者中的小众，所以完整的、高质量的环境配置的教程、博客少的可怜，而完整的从编译到调试的配置教程几乎没有，所以我配置好的.vscode算是纯原创配置了，所以在这里分享一下，大家也可以少走一点弯路。\n前期准备网上教程还是有一些的，这里只讲一下要注意的细节\n\nrust安装： 按照官网的安装教程来就可以，Windows上默认安装的是MSVC ABI的版本（你电脑上有VS就可以正常安装，没有的话它会让你下载一个VC++的软件包），当然你也可以装GNU ABI版本，这决定了后面的debug用的是MSVC还是GDB。本文只介绍MSVC版本的配置。\n工具安装： racer需要手动安装，前面还需要装个rust的源码。具体步骤参考此文只要看下载rust源码和racer部分就好。剩下的部分在vscode里装插件的时候会提示你安装。\n\nVSCode配置vscode插件安装\n要进行debug，需要安装微软自家的插件C/C++和Native Debug插件。用VSCode写过c或c++的人应该都装了这两个插件。\n\n先安装Rust(rls)再安装Rusty Code，过程中提示你装的工具都点确定就会帮你自动装好。然后C:\\Users\\&lt;username&gt;\\.rustup\\toolchains里应该就会有两个版本的工具链，stable和nightly。这些步骤完成后用VSCode写Rust，已经具备了代码补全、智能提示等基础功能了，另外在vscode里ctrl+shift+p再输入cargo可以看到vscode里已经有了cargo的命令及一些常用命令的快捷键。\n\n\n可视化debug为了在debug的时候可以可视化，即可以在VSCode的调试区查看变量的值和堆栈调用情况等，需要把~\\.rustup\\toolchains\\nightly-x86_64-pc-windows-msvc\\lib\\rustlib\\etc里的文件全部复制粘贴到~\\.vscode\\extensions\\ms-vscode.cpptools-0.11.2\\debugAdapters\\vsdbg\\bin\\Visualizers\n.vscode配置开一个文件夹，以后都在这个文件夹下用Cargo新建项目。用VSCode打开新建的文件夹，点小蜘蛛再点调试那一栏的小齿轮，添加launch.json配置文件，内容如下\n&#123;    // 使用 IntelliSense 了解相关属性。     // 悬停以查看现有属性的描述。    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387    &quot;version&quot;: &quot;0.2.0&quot;,    &quot;configurations&quot;: [        &#123;            &quot;name&quot;: &quot;(Windows) Launch&quot;,            &quot;type&quot;: &quot;cppvsdbg&quot;,            &quot;request&quot;: &quot;launch&quot;,            &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/target/debug/$&#123;workspaceFolderBasename&#125;.exe&quot;,            &quot;args&quot;: [],            &quot;stopAtEntry&quot;: false,            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,            &quot;preLaunchTask&quot;: &quot;cargo build&quot;,            &quot;environment&quot;: [],            &quot;externalConsole&quot;: true        &#125;    ]&#125;\n\n再点菜单栏的任务-&gt;配置任务-&gt;使用模板创建tasks.json文件，配置内容如下：\n&#123;    // See https://go.microsoft.com/fwlink/?LinkId=733558    // for the documentation about the tasks.json format    &quot;version&quot;: &quot;2.0.0&quot;,    &quot;tasks&quot;: [        &#123;            &quot;type&quot;: &quot;shell&quot;,            &quot;label&quot;: &quot;cargo build&quot;,            &quot;command&quot;: &quot;cargo&quot;,            &quot;args&quot;: [                &quot;build&quot;            ],            &quot;problemMatcher&quot;: [                &quot;$rustc&quot;            ]        &#125;    ]&#125;\n\n具体使用然后就和写c\\c++一样了，你写完rust代码，在行号左侧设置断点，点调试区的绿色开始键，就会自动帮你cargo build然后运行程序开始调试。Enjoy Rust!\n参考\nhttps://code.visualstudio.com/docs/editor/variables-reference\nhttps://www.brycevandyk.com/debug-rust-on-windows-with-visual-studio-code-and-the-msvc-debugger/\n\n","tags":["rust","vscode"]},{"title":"VIM杂记(一)","url":"/2020/03/09/VIM%E6%9D%82%E8%AE%B0-%E4%B8%80/","content":"写在前面每次都觉得我的vim走上正轨了\nthree months later…\n卧槽 这什么bug？这个插件怎么用来着？那个命令怎么写来着？\nthree days later…\n“我又好了！”\n为了再次避免这种情况，打算把每次学到东西记录下来。查博客总比查百度高效一些。由于只是记录当前学到的东西，又因为认识的片面性，所以可能会有错误，反正后面发现是错误了，再在后续的杂记里更正就是了。\n1.1关于Vundle使用Vundle插件进行Vim插件的统一管理，包括安装、卸载等功能。 一般单独开一个文件.vimrc.bundles列出所要加载的插件，在.vimrc里需要载入该文件。 在.vimrc.bundles中列出所需插件之前，需要先将Vundle的代码包加入vim的运行时路径：\nset rtp+&#x3D;~&#x2F;.vim&#x2F;bundle&#x2F;Vundle.vim&#x2F;\n其中rtp应该是runtime path的意思，vim有自己的运行时来解析执行vimscript脚本，想要调用预先定义在文件中的函数，自然需要将这些文件地址加入运行时地址列表。我猜后面其他插件的文件路径都是由Vundle负责加入rtp的。\n在下面这样的代码块中加入所需要使用的插件\ncall vundle#begin()Plugin &#39;VundleVim&#x2F;Vundle.vim&#39;Plugin &#39;xxx&#x2F;xxxxx&#39;...call vundle#end()\n注意Vundle必须是第一个列入的插件。call是vimscript中的函数调用，#类似python或java中的.。如果不打算使用某插件可以注释掉对应的Plugin那一行，而不需要卸载。\n安装插件在.vimrc.bundles加入Plugin xxx/xxxxxxx，保存文件后在vim下执行\n:PluginInstall\n\n卸载插件在.vimrc.bundles注释Plugin xxx/xxxxxxx，保存文件后在vim下执行\n:PluginClean\n\n1.2\nultisnips是一个snippets的引擎，vim-snippets里面有很多常用的脚本。这两个插件需要配合使用。\n发现自己的ultisnips有bug，然后我重装了，然后出现更大的bug，查了半天是github上的最新版本的代码支持python3了，但是我的vim只支持python2, 于是手动下了github上之前版本的代码放入.vim/Bundle文件夹。 但是还是有bug，发现我的Enter键没法回车了，查了半天bug，甚至阅读了ultisnips的部分代码（主要是./autoload/UltiSnips/map_keys.vim和./autoload/UltiSnips.vim），经过各种调试发现是，somehow，我的vim在select模式下&lt;c-m&gt;和&lt;cr&gt;是捆绑的，我配置了用&lt;c-m&gt;来展开，结果就导致了&lt;cr&gt;也映射到了展开snippets的命令上。。。TAT。最后试了几个键发现c-l是好用的，也顺手。\n另外，我观察到在打开vim的瞬间，ultisnips会先跑两个样例，如果这两个样例有问题，就会在打开vim的时候报错，一般情况下用户是察觉不到这个过程的。\ninc、incc、mainn、fori都是c语言中常用的snippets\n在我的配置中&lt;c-l&gt;可以进行展开或者跳到下一个placeholder，&lt;c-k&gt;回到上一个placeholder。\n:UltiSnipsEdit可以查看对应当前编辑文件的snippet配置文件 \n\n1.3在vim插件的代码中可以通过verbose map **和echo进行调试。:map、:snoremap等可以查看对应模式下的按键映射。关于按键映射的知识点，可参考https://blog.csdn.net/u012291393/article/details/78650512\n1.4多行缩进\n:10,20&gt;:12,13&lt;\n跑Python代码\n:py import sys; print(sys.version)\n多行注释: ctrl+v进入列编辑模式，在编辑模式中，在行间上下移动光标，选择需要编辑哪些行的对应的列，之后使用I（大写）进入列插入。 插入注释符，按Esc退出列编辑模式即可实现多行注释。\n删除注释：按v,进入visual模式,横向选中列的个数(如”/ /“注释符号,需要选中两列),再按ctrl+v 进入列编辑模式,向下或向上移动光标,选中注释部分,然后按d, 就会删除注释符号。\n","tags":["VIM"]},{"title":"黎曼Zeta函数的几种延拓方法","url":"/2021/08/22/analytic_continuation_of_riemann_zeta_function/","content":"引子黎曼函数7定义为一个无穷级数函数在黎曼的素数分布的理论1及大名鼎鼎是黎曼猜想2中占据了重要的地位。但是原始的定义在，而解析数论中所使用的函数定义在几乎整个复平面上（除了极点），因此严格意义上讲他们不是一个函数，因为定义域不同。但是在定义域重叠的部分，函数取值是一致的，所以后者实际上是前者的解析延拓。解析延拓是复变函数理论中用于扩展函数的定义域的方法，为函数在未定义的区域上赋值，并且使拓展后的函数依然满足满足全纯或亚纯等条件。黎曼是最先对函数进行解析延拓的数学家，并发现延拓后的函数的零点的分布情况（黎曼猜想指出函数的所有非平凡零点满足）与素数的分布情况存在密切的联系5。且不论黎曼猜想对后世数学发展的影响，任何完整但粗浅地了解过黎曼的这一工作的人都会为黎曼光辉耀目的直觉所折服。\n\n除了黎曼在其论文中提出的延拓方法，还存在一些其他的延拓方法。本文将对我在一些资料中所接触到的延拓方法进行总结整理。\n准备工作在开始介绍函数的解析延拓方法之前，先做一些概念和工具上的铺垫。\n首先注意到，是调和级数，他是发散的。欧拉证明了对于实数，是收敛的。可以证明，对复数，若其实部大于1，即满足，函数也是收敛的。所以函数的定义域可以自然扩展到复平面上的区域。\n定义多重对数函数（Polylogarithm）6以及伽马函数(阶乘函数的解析延拓函数，由欧拉提出)根据性质（推导见3可以得到由此我们得到了函数的积分形式，注意到这一积分形式并没有拓展函数的定义域，仍然是。\n类似的，我们可以得到另外一个关系式这里出现了一个新的函数（Dirichlet eta function8，它也是一个无穷级数和。函数和函数关系密切，可以观察到，无论是级数形式还是积分形式，这两个函数都存在很明显的对称性。在级数形式中，使函数的每一项正负号交替即可得到函数，因此函数也被称为alternating zeta function。欧拉也研究过函数，并且证明了它的定义域为，也就是在这个区域上级数收敛，另外注意到，积分形式的定义域为。\n可以证明函数和函数存在关系因为相当于函数中的所有偶数项，因此从函数中减掉两倍的偶数项，即得到正负交替的级数和。\n整理上式得\n上面的关系虽然是从级数形式中证明得到的，但是对于积分形式也是成立的（废话！）。注意到这一关系式实际上将函数的定义域延拓到了。\n函数的解析延拓黎曼的方法黎曼在其论文中通过路径积分对函数进行了解析延拓1其中积分路径由三部分组成：1.从正无穷沿着正实轴到一个很小的正数2.以原点为圆心，逆时针旋转一圈3.从沿着正实轴到无穷远处最后取极限\n\n通过对称性进行延拓我们已经通过函数和函数的关系将函数的定义域扩展到了，进一步研究函数，可以发现其在的区间内存在某种对称性（对称轴为）。这种对称性具体表现为Riemann’s functional equation或者等价形式注意到上式可以帮助我们把函数的定义域拓展到的区域，因为等号右边的是有定义的。\nRiemman本人给出了Riemann’s functional equation的两种证明方法，后人也给出了各种证明方式。这里简单介绍两种：1）通过拉式变换和柏松求和，得到对称性（具体见4）2）Hardy证明了用函数表达的Riemann’s functional equation在的区间成立9. pp. 16-17\n最后利用对称性写分段函数完成延拓\n易知，该分段函数的定义域为。利用上式，我在Python中实现了函数，并与第三方包中实现的函数进行了比较，误差在允许范围内，验证了实现的正确性。代码如下\nimport numpy as npfrom scipy.integrate import quadimport mpmath as mpmp.dps = 100mp.pretty = Truedef quadc(func, a, b, args):    \"\"\"        help function to attain integration         of a complex-valued function    \"\"\"    def real_func(x):        return np.real(func(x, *args))    def imag_func(x):        return np.imag(func(x, *args))    real_integral = quad(real_func, a, b)    imag_integral = quad(imag_func, a, b)    return real_integral[0] + 1j*imag_integral[0]Gamma = lambda s: \\quadc(lambda x, s_: x**(s_-1) * np.exp(-x), 0, np.inf, args=(s, ))I1 = lambda s: \\quadc(lambda x, s_: x**(s_-1) * np.exp(-x)/(1 - np.exp(-x)), 0, np.inf, args=(s, ))I2 = lambda s: \\quadc(lambda x, s_: x**(s_-1) * np.exp(-x)/(1 + np.exp(-x)), 0, np.inf, args=(s, ))def zeta(s):    \"\"\"piecewise function\"\"\"    if np.real(s) &gt; 1:        return I1(s) / Gamma(s)    elif np.real(s) &gt;= 0:        return I2(s) / (Gamma(s) * (1 - 2**(1-s)))    else:        return 2**s * np.pi**(s-1) * np.sin(np.pi*s/2) * Gamma(1 - s) * zeta(1 - s)s = -1 / 2 + 1jprint(zeta(s))# Output: -0.0008178931310828252 - 0.22307168869792196jprint(mp.zeta(s))# Output: -0.000817893132952545 - 0.223071688697778j\n\n利用阿贝尔求和法我在阅读相关资料的时候，猜测得到了另外一种延拓方法，并使用Python进行了验证。在我接触到资料中，未有明确地提出此种延拓方法，但是据我所知，欧拉在研究函数和函数时用到了这一方法。利用这一方法，欧拉得到了一个“著名悖论”———自然数求和公式，这个等号实际上不成立，严谨的表述应该是，其中函数的定义域为。\n自然数求和公式的左侧是一个发散的级数和，事实上，对于对于复数，当时，都是一个发散的级数和。数学中存在专门为发散级数确定（赋值）有限的和的方法10。这种方法实际上是不严谨的，甚至是有害的，正常情况下应该通过解析延拓等方法绕过处理发散级数的问题（物理学家们经常使用发散级数求和的技巧，如重整化方法等）。N. H. Abel曾说\n\nDivergent series are in general something fatal, and it is a disgrace to base any proof on them.\n\n可见除非迫不得已，或者是为了在不严谨的语境下洞见某种规律（正如欧拉所做的），数学家一般不接受通过发散级数求和方法来研究问题。因此我尝试研究此类方法，完全是出于个人兴趣。\n阿贝尔求和法10可以用来处理是一个发散级数的情况。对于发散的无穷级数，阿贝尔和定义为\n我们可以通过阿贝尔求和法为函数在定义域上确定函数值。我用Python验证了这样的想法\ns = -1 / 2 + 1jeta = 0for i in range(1, int(1e10)):    eta += i**(-s) * (-1)**(i + 1) * (1 - 1e-4)**i    zeta2 = eta / (1 - 2**(1-s))    print(np.real(zeta2) * 12)# Output: -0.0008262168997433036-0.2230608774298546j\n对比上一小节的结果，误差在可接受范围内；通过上面的代码，我还验证了自然数求和公式的结果。通过计算机程序，验证了这样的延拓方法在数值计算上是有效的。\n另外，欧拉通过阿贝尔求和法，也发现了Riemann’s functional equation的等价形式。\n小节函数真美啊。\n参考\n[1] Riemann, Bernhard (1859). “Über die Anzahl der Primzahlen unter einer gegebenen Grösse”\n[2] Wiki on “Riemann Hypothesis”\n[3] 读懂黎曼猜想（2）——Mellin变换、素数计数函数、与欧拉乘积\n[4] 读懂黎曼猜想（3）——平凡零点、非平凡零点与黎曼猜想\n[5] 读懂黎曼猜想（5）——精确公式和素数计数函数的渐近展开\n[6] Wiki on “Polylogarithm”\n[7] Wiki on “Riemann zeta function”\n[8] Wiki on “Dirichlet eta function”\n[9] E.C. Titchmarsh, The Theory of the Riemann Zeta Function, Oxford Univ. Press, 1951\n[10] Wiki on “Divergent series”\n\n","tags":["analytic number theory","complex function"]},{"title":"windows上利用docker安装MySQL","url":"/2019/03/30/windows%E4%B8%8A%E5%88%A9%E7%94%A8docker%E5%AE%89%E8%A3%85Mysql/","content":"安装docker在Windows上安装Dockers Toolbox，下载链接，选择ce版本。安装完成后有三个软件，一个是VM Virtualbox，负责装载docker-machine虚拟机；一个Quickstart是一个虚拟终端，点击这个应用后会自动新建一个machine；另一个是一个GUI,基本不用。\ndocker使用与配置docker运行在一个Linux系统的虚拟机上，即machine，第一次点开Quickstart默认创建的machine的名字一般是default；在machine中可以新建和运行容器，容器可以理解为在原始machine的基础上叠加环境信息，并形成一个新的“虚拟机”，因此运行在同一个machine上的不同的容器之间是隔离的；在Windows的cmd或者Powershell中可以通过docker-machine对虚拟机进行管理\n# 创建名叫default的machinedocker-machine create --driver=virtualbox default# 停止machinedocker-machine stop default # 重启用restart，启动用start# 删除一个machinedocker-machine rm default# 查看machine信息，包括其IP地址docker-machine ls\n通过docker-machine可以在Windows环境中获得machine的环境，从而无需登录machine就可以在cmd中执行docker开头的指令（docker本是machine中的应用而不是在Windows中）。执行\n# 创建名叫default的machinedocker-machine env default #根据输出执行命令\n即可获得环境，例如我们现在可以执行docker version。\\可以通过docker-machine登陆machine\ndocker-machine ssh default\n登陆后sudu vi /var/lib/boot2docker/profile,在EXTRA_ARGS中添加国内的镜像源\n--registry-mirror https：&#x2F;&#x2F;registry.docker-cn.com\nexit退出虚拟机，重启虚拟机，然后就可以开始拉镜像了。\n安装Mysql# 安装镜像docker pull mysql# 新建容器docker run -d -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=123 mysql:latest\n一些常用操作\n# 查看镜像docker image ls# 查看容器docker ps -a# 暂停容器docker stop $(containerID)# 启动容器docker start mysql # 后面是容器的name# 登陆容器docker exec -it mysql bash\n远程连接Mysql登陆容器后登陆MySQL\n# 以root身份登陆，密码为123mysql -u root -p\n进入MySQL引擎\nCREATE USER &#x27;szw&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;szw&#x27;;GRANT ALL PRIVILEGES ON *.* TO &#x27;szw&#x27;@&#x27;%&#x27;;\n下载Navicat for MySQL，打开应用，点击连接，填写相关信息，IP为default虚拟机的IP，账号szw,密码szw，然后就正常连接了。\n","tags":["docker","MySQL"]},{"title":"在Python中写lambda calculus","url":"/2019/09/08/%E5%9C%A8Python%E4%B8%AD%E5%86%99lambda-calculus/","content":"前言可能会有一个系列，专门记录自己研究过的奇技淫巧。 虽然有时候我们会觉得奇技淫巧是花里胡哨，华而不实的，但是当自己写出来的时候，就还是“真香”。 况且奇技淫巧之中其实蕴含着优美与真理，主要看你怎么去理解它们了。 这次的问题来源于我在网上看到的一个用lambda表达式写递归的Python语句\nfactorial = (lambda a:lambda v:a(a)(v))(lambda s: lambda x:1 if x==0 else x*s(s)(x-1))  # 实现了递归print(factorial(5)) # 120\n上面这个求阶乘的表达式我看了快半个小时才觉得自己大概是看懂了。好奇心驱使我开始往下挖坑，想看怎样能更好地理解这种写法。 因为学过Haskell，所以我知道这里可能涉及到了lambda calculus和 Y combinator的内容。 之前看过一点这个topic，但是也没有太深入研究。\n先扯扯lambda calculuslambda calculus可以理解为一个数学系统，其中最基本的元素或者说研究对象是函数, 通过函数来构造出我们做计算所需要的所有“材料”（比如自然数，四则运算符等）。 其实这有点像集合论，通过集合论可以构造出现代数学的几乎所有内容，比如皮亚诺公理就是用集合（集合套空集，集合套集合的骚操作）构造自然数。 说回lambda calculus，lambda calculus中的函数具有一些特征，这些函数是单参数的，它们能且只能接受一个函数作为参数； 当我们把一个函数作用于另一个函数（后者作为前者的参数），得到的返回值也是一个单参数函数。 这样整个系统其实就封闭了，我们可以在里面搭积木而不再需要其他任何东西了。 然后看看notation:\nλ x. E   # 这表示一个函数，函数参数为x，E为函数所作运算的具体表达式M N      # 将函数M作用于函数N，函数作用是可以省略括号的\n第一个式子中的E可以包含x，也可以不包含，E就相当于一个f(x)， 如果f(x)的表达式中不包含x，就意味着函数的输出和输入无关。 lambda calculus中所有合法的表达式的值都是单参数函数。 另外函数是左结合的，即X Y Z = (X Y) Z =(X(Y))(Z)，所以X (Y Z)这个式子里的括号是不能去的。 函数式编程中的lambda表达式就是借鉴了λ x. E这样的写法，例如我们可以在Python中这样定义函数（Python借鉴了函数式编程）:\nf = lambda x: x + x  # f(2) 的值是4g = lambda x, y: x * y  # f(2, 3) 的值是6\n但是λ x. E和编程语言中的lambda表达式其实是有区别的，首先语法上lambda表达式并没有限制参数的个数（对于有柯里化特性的语言写两个参数在语义上还是可以理解成单参数函数的，例如Haskell），然后就是参数的类型不一定是函数，所创建的函数的返回值类型也不一定是函数。注意，lambda表达式的返回值是函数，但是这个函数的返回值，即它的输出是要看它接收参数后的运算结果，在lambda calculus中这种运算结果的值仍然是函数。 然后看一些基本的恒等式\nλ x. F x = F(λ x. E) T = E[x:=T]λ x. E[x] = λ y. E[y]\n第二个式子的右侧是值把表达式E中的所有x都替换成T，第三个式子是说把参数名字换掉不改变它所代表的函数。 这三个式子的成立都很显然，应用它们做一些数学证明的时候可能从左推到右，也可能从右推到左。然后我们看看，lambda calculus中是如何定义自然数的\n0 = λ f. λ x. x1 = λ f. λ x. f x2 = λ f. λ x. f (f x)3 = λ f. λ x. f (f (f x))\n我们称这样定义的自然数为Church数（不是教堂，是lambda calculus的发明者的名字）。 对这种定义的一种粗略的理解是，自然数n是这样一个函数，它接收任意一个函数f，返回了一个函数A，这个函数A在接收任意一个函数x,返回一个函数B，这个B的值等价于f作用于x，连续作用n次的结果。 但是，为什么要这样定义呢？后面我们还要定义各种运算，定义完的结果就是1+1=2这样的等式的成立是可以在lambda calculus框架下进行证明的。所以为什么这样定义，因为自洽。 虽然可以证明某某等式的成立，但是lambda calculus中的表达式往往又“臭”又长，用人脑去解析它们真的十分费力，所以我就想能不能用Python对表达式进行计算，然后print出一个函数所代表的Church数的值。\nPython模拟lambda calculus我希望的模拟不是字符串的规约推导，而是用Python的lambda表达式去比较真实的模拟，同时尽可能的保持lambda calculus的特性，也就是所有表达式或名字的值都是函数类型。 所以我写了下面一段十分神奇的代码：\n# interpreting and visualizedef x_():    return 0def f_(x=None):    return lambda : 1 + x()def interpret(f):    &#x27;&#x27;&#x27;查看一个函数的自然数值，具体见下文&#x27;&#x27;&#x27;    print(f(f_)(x_)())def predicate(f):    &#x27;&#x27;&#x27;查看一个函数的bool值，具体见下文&#x27;&#x27;&#x27;    if f(f_)(x_)() == 0:        print(False)    else:        print(True)\n这段代码几乎满足了我的所有要求，唯一的不足已经是语言本身的不足了（Python不支持惰性求值）。 具体的使用看后面的例子，后面例子里的所有代码（除了调用interpret或predicate）都是在对函数进行运算了，输入、输出和各种变量什么的全都是单变量函数。\n自然数我们现在开始做一些定义和测试。 根据上面提到的Church数的定义，我们可以这样写\nChurch_0 = lambda f: lambda x: xChurch_1 = lambda f: lambda x: f(x)Church_2 = lambda f: lambda x: f(f(x))Church_3 = lambda f: lambda x: f(f(f(x)))\n代码定义完全照抄上面的数学定义。 然后我们print它们的值看看\ninterpret(Church_0)  # 0interpret(Church_2)  # 2interpret(Church_3)  # 3\n后面的注释就是打印的结果，十分完美。\n运算符然后我们再利用这套代码定义一些运算符看看。 下面是我们在这篇文章中将要使用的运算符的数学定义\nSUCC = λ n. λ f. λ x. f (n f x)  # 加1运算PLUS = λ m. λ n. λ f. λ x. m f (n f x)  # 求和运算MULT = λ m. λ n. m (PLUS n) 0  # 求积运算PRED = λ n. λ f. λ x. n (λ g. λ h. h (g f)) (λ u. x) (λ u. u) # 减一运算\n这里先讲一下二元运算符PLUS和MULT，PLUS x y 这个式子表示 x + y，如果x是Church数1，y是Church数2，PLUS x y的返回值就是Church数3。 但是PLUS仍然是一个单参数函数，它接收函数x然后返回 PLUS x，PLUS x是一个函数，这个函数接收一个函数y然后返回x + y，即PLUS x y = (PLUS x) y，这就是所谓的柯里化。 MULT运算同理。 下面我们上代码\nSUCC = lambda n: lambda f: lambda x: f(n(f)(x))interpret(SUCC(Church_3)) # 4PLUS = lambda m: lambda n: lambda f: lambda x: m(f)(n(f)(x))interpret(PLUS(Church_3)(Church_2)) # 5MULT = lambda m: lambda n: m(PLUS(n))(Church_0)interpret(MULT(Church_2)(Church_3)) # 6PRED = lambda n: lambda f: lambda x: n(lambda g: lambda h: h(g(f)))(lambda u: x)(lambda u: u)interpret(PRED(Church_3)) # 2\n虽然这些定义看起来很吓人，但是结果都十分正确。 我们试一个更复杂的\ninterpret(PRED(MULT(Church_2)(Church_3))) # 5\n也是正确的。 当我照抄数学定义然后成功print出正确的结果的时候，感到惊喜且惊奇。 我们只是搭好了一个简单的地基，然后就看着这些建立在地基之上的复杂事物表现出我们所期待的行为。 这就是数学的魅力吧。\n逻辑运算上文说lambda calculus可以定义出我们用来做计算需要的所有东西，这里的计算就包括逻辑计算。和C语言类似，我们定义表示0的函数为False，而其他的函数为True。 看一下具体的数学定义\nTRUE = λ u. λ v. uFALSE = λ u. λ v. v\nPython的代码定义如下\nChurch_True = lambda u: lambda v: uChurch_False = lambda u: lambda v: v\n根据我们之前提过的恒等式中的第三条，我们知道False和0在lambda calculus中是同一个函数。所以除了interpret，我写了另一个函数predicate，它把函数看作是一个逻辑断言，并打印出其真值。我们来测试一下\npredicate(Church_False)  # Falsepredicate(Church_True)   # Truepredicate(Church_0)      # Falsepredicate(Church_2)      # True\n与我们预期的一样，除了0, 我们之前定义的Church数都被认为是逻辑True。 这样我们就在lambda calculus的背景下构造了一个布尔代数系统，我们可以定义各种逻辑运算符和布尔函数\n# AND = λ p.λ q.p q pAND = lambda p: lambda q: p(q)(p)# OR = λ p.λ q.p p qOR = lambda p: lambda q: p(p)(q)# NOT = λ p.p FALSE TRUENOT = lambda p: p(Church_False)(Church_True)predicate(NOT(OR(Church_False)(Church_True)))  # False\n基于0和False的一致性，我们可以定义一个判断输入是否为0的函数，当且仅当输入为0时返回True：\n# 数学定义： ISZERO = λ n. n (λ x. FALSE) TRUEISZERO = lambda n: n(lambda x: Church_False)(Church_True)predicate(ISZERO(Church_0))  # Truepredicate(ISZERO(Church_3))  # False\n递归现在到了最激动人心的part。 我们以阶乘函数为例来进行探讨，首先来看看在Haskell中我们如何用递归的方式定义阶乘函数（用Haskell举例是因为Haskell写出来的阶乘函数特别接近我们用自然语言进行的递归算法的描述，同时又可以比较形式化）\nfactorial 0 = 1factorial n = n * factorial (n-1)\n从中我们看到了递归函数的一个重要特征，就是函数名会出现在函数定义里头。 所以乍看之下我们会觉得lambda表达式无法表达递归函数，如果硬着头皮，我们会写出像下面这样的式子\nF = λ x. F (PRED x)\n这个式子存在两个问题，一是在数学中我们一般不允许循环定义，你还没有定义完成F是啥，就还不能使用F，另一方面，即使语法上允许我们这么表达一个函数，这个函数也有可能是个没有尽头的死循环（注意没有输出就不是函数了）。 不过Python中的lambda表达式允许我们进行“循环定义”，因为与数学不同，Python中的函数是先定义再调用的，只有在调用的时候（也就是你在函数名后面加()的时候，如fun()）才会真正去执行一个函数的代码，而定义的时候只是将一个函数名和一串代码绑定起来，并不会去分析这段代码究竟干了什么。所以我们可以像下面这样定义\nFACT_ = lambda n: n(lambda u: MULT(n)(FACT_(PRED(n))))(Church_1)interpret(FACT_(Church_0))  # 1interpret(FACT_(Church_3))  # 6\n这个FACT_功能良好。 有两点十分有趣，我们看到0的阶乘十分自然的等于1，说明数学家们当初规定0! = 1不是随便规定的，是有一定的道理的。 另一点就是FACT_并没有陷入死循环，这一点看似很奇怪，因为我们似乎并没有像传统递归写法那样设置临界条件，那这个循环函数调用是如何停下来的呢？ 这里就涉及到Church0的定义的奥妙之处了\n0 = λ f. λ x. x\n实际上函数运算到最后会出现0(MULT n (PRED n))(1)这样的情况，这个时候按0的定义，他会直接忽略传进去的(MULT n (PRED n))而直接返回函数1。 (MULT n (PRED n))只出现在参数里但不再出现在函数表达式里，所以也就不会再去往下计算它了。说到这里，阶乘函数的实现还是依赖于Python的语言特性，而不是纯数学的lambda calculus的定义，而且看起来lambda calculus没法使用还没定义好的名字，所以似乎也写不出递归函数。 但是别慌，数学家们还是研究出来了，lambda calculus中有个叫Y combinator（Y组合子）的东西为lambda calculus提供了递归的实现手段\nY = λ f. (λ x. f (x x)) (λ x. f (x x))\n其实并不神秘，稍作思考我们就可以得到下面这个结论\nY F = F(F(F(F(. . .)))) # 无限循环调用\n然后我尝试在Python中实现Y combinator\nY = lambda f: (lambda x: f(x(x)))(lambda x: f(x(x)))F = lambda g: lambda n: n(lambda u: MULT(n)(g(PRED(n))))(Church_1)FACT = Y(F)interpret(FACT(Church_3))\n然后不幸发生了，到第三行Python报错了，说是递归爆栈了，也就是陷入了死循环。这是因为Python不是惰性求值的，当我执行FACT = Y(F)的时候，解释器就会去执行Y函数的计算，按照定义自然会出现无限调用的情况。 lambda calculus所希望的是，你先别去计算Y(F)的返回值究竟是个什么函数，等这个函数作用了Church_3再去实施计算，到时候Church_0就会负责把死循环截断。所以很多函数式编程语言都会设计成惰性求值来增强语言的表达能力，避免不必要的死循环。那么路走到这里，就走到尽头了吗？并没有，回顾我们开篇提到的阶乘函数的实现，它也是用lambda表达式写的，也没有使用未定义的名字，于是我仿照它不使用Y combinator，重新定义了阶乘函数\nT = λ f. λ x. f f xG = λ g. λ n. n (λ u. MULT n (g g (PRED n))) 1FACT = T G\n然后使用Python实现并测试\nT = lambda f: lambda x: f(f)(x)G = lambda g: lambda n: n(lambda u: MULT(n)(g(g)(PRED(n))))(Church_1)FACT = T(G)interpret(FACT(PLUS(Church_3)(Church_2)))  # 120\n成功了。 一个合理的解释是，在数学上两个FACT是同一个函数，只是我们通过数学上的变换调整了函数的组织方式，从而改变了其中的运算顺序，避免了因为不支持惰性求值而造成的问题。 这个猜想的正确性需要需要通过数学证明来保证，也就是证明Y F = T G。\n证明我们观察到G和F的主要区别就在于g (PRED n)和g g (PRED n)，所以我们的入手点也是这里，先尝试把两个g变成一个函数来表示\nG = λ g. (λ h. λ n. n (λ u. MULT n (h (PRED n))) 1)(g g)  = λ g. F (g g)\n所以有\nT G = (λ f. λ x. f f x)(λ g. F (g g))    = λ x. (λ g. F (g g)) (λ g. F (g g)) x    = (λ g. F (g g)) (λ g. F (g g))    = (λ f. (λ g. f (g g)) (λ g. f (g g))) F    = Y F\n证明成功。\n结尾这次的探究启发了我们写递归函数的方式，并不是只有自己定义（中出现）自己才能实现递归。当然我不会在Python中这样写递归函数，因为可读性太差，对于不了解函数式编程的人，这样的代码非常不友好。即使在Haskell中，我也不会这样写，因为Haskell中有更优美的递归写法。但是lambda calculus中对函数的变换、组合和使用的精髓是值得我们学习的，这有助于我在写函数式的Python语句或写Haskell时更清楚我能写什么，我能怎么写。\n参考\nLambda_calculus\n各语言Y组合子大比拼\n\n","tags":["lambda calculus","python"]},{"title":"浅谈Python闭包与装饰器","url":"/2018/05/24/%E6%B5%85%E8%B0%88Python%E9%97%AD%E5%8C%85%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8/","content":"前置知识加载、解释与执行python是解释型语言、脚本语言，一大特点是一行语句只有需要被执行时才会被编译一次，编译后立即执行。所谓的“需要被执行”指python解释器“阅读”代码的顺序，通常来说是从上往下一行一行“阅读”，也就是编译并执行完了当前行，才会执行下一行；当然也有例外的时候，比如设置了for循环（需要注意的是，假设for循环中有4行代码，循环3次，那么解释器实际上编译了12行），还有就是调用方法（函数），解释器会跳转到方法代码块开始编译执行。观察如下代码：\ndef fun(a):    a = a ** 2    return aprint(&quot;调用fun方法&quot;)print(fun(a))\n这段代码的编译执行顺序是1、4、2、3、5。（提示：函数定义真正被执行的只有def行，函数体中的代码只是以字符串的形式简单地加载进了内存，并没有被编译，函数每一次调用的时候才进行一轮编译执行；第五行中出现了函数调用，会先跳转到函数块，执行完函数中的语句拿到返回值后跳转回来执行print）\n一切皆对象python中一切皆对象的思想比Java更为彻底。int型等所有变量是对象，函数是对象（类也是对象，这个暂时不做展开）。是对象就会有对象的属性和方法，这里介绍一种很有用的方法，id(对象名)，这个方法会返回对象名所指向对象的地址，利用它可以很好的研究代码，观察各个变量的内存位置。因为一切皆对象，所以python中的一切变量都是引用变量，\na = 1a = 2b = 2a = funprint(a(2))print(id(a) == id(b))\n第一行到第二行，并不是给a变量赋了新的值，而是把a的指向从存放对象int 1的内存地址改到了存放int 2对象的内存地址（事实上python的虚拟机会在程序运行前提前创建好0到256的int对象，于是你会发现代码中id(a)和id(b)是一样的，因为他们都指向同一对象）；函数也是对象，是对象就可以被引用，所以第四行表示给fun函数取了一个新名字a，a从指向2变成了指向fun（注意一下fun和fun()的区别，前者的返回值是fun所指的函数对象，后者的返回值是函数里return的东西）。\n闭包有了前置知识就很容易学习、理解闭包了。闭包说白了，就是定义一个外层函数，这个外层函数的功能是定义一个内层函数，并返回这个内层函数对象。\ndef outer(a):    def inner(b):        return a + b    return innerf = outer(1)print(f(2))  #  输出3\n1到4这个结构就称为闭包，第六行的功能就是得到了一个叫f的、可以给传入的一个数字加1并返回的函数。上面代码的执行顺序是1、5（第五行为空）、2(识别到第六行有函数调用，所以先跳转执行函数outer，生成一个inner函数对象，并把inner函数体中的代码载入内存)、4、6、3（通过f找到内存中之前生成的inner函数，执行函数语句）、7。\nf = outer(1)g = outer(2)\n这里调用了两次outer，实际上定义了两次inner，产生了两个不同的函数对象（内存地址不同，功能也不同，f()是传入的数字返回加1的结果，g()是返回加2的结果）。这也是为什么outer的返回值必须赋给（被引用给）一个变量，因为outer()是可以多次利用的，每次调用都会产生一个新的inner函数对象，那么你就需要不同的名字来区别这些函数，方便下次找到他们，比如上面的f和g（outer函数体外面是不属于inner这个名字的作用域的，所以在outer外通过inner()调用函数是非法的，在python解释器看来，这个位置没有定义过一个叫inner的函数或者变量，所以每次产生的inner对象虽然载入了内存，但是出了outer函数体之后就失去了名字，所以必须被一个外部的变量名引用，下次需要调用它的时候才能明确你到底需要调用内存中哪一个函数）。我们再来看看新生成的inner对象载入内存这个过程的一些细节，\ndef outer(a):    def inner(b):        return a + b    a = 2    return innerf = outer(1)print(f(2))  # 输出4\n这段代码和之前的区别就是def之后加了一句a = 2,结果输出就等于4了。如果你看懂了我之前说得调用和定义、执行和加载的区别，你就会理解定义inner对象的时候只是把return a + b这段字符串载入了内存，并没有进行编译，所以当之后通过f(2)调用，编译并执行return语句的时候就需要去看一下现在的a等于几。但是，我想说的是，通常来说，一个函数内部定义的变量，或者其形参的生命周期在函数结束的时候就结束了，也就是说outer结束的时候，解释器理应已经不认识那个叫a的变量了（和inner的道理一样），或者说内存中已经不存在叫a的变量了，那么当我们在outer外部调用f(2)的时候，解释器在编译return语句的时候去哪里找的a呢？这就是闭包之所以为闭包的特殊之处（如果你去看官方文档的闭包定义，你会觉得不知道它在讲什么，实际上它在说我下面要讲的这个特性），解释器在执行def inner(b):的时候会在内存中开一块内存用于存放新生成的inner函数对象和这个对象的一些成员信息，除了将函数体语句（这里指return a + b）载入这块内存,还会载入变量a（a在是inner中被调用的，但是不是在inner中定义的局部变量），相当于捆绑了一份a给新生成的inner对象，所以当outer结束的时候，a并没有被销毁，而是存活在inner对象的内存中（注意，我这里所说的a是否存活，不是指a所指的那个int对象，不是说int对象存到了inner对象的内存中，这里的a是一个引用，你应该把a理解为一份地址信息，而这个地址就是a所指的int对象的地址，P.S 如果你想学好python，就必须习惯所有的变量名、函数名都只是引用）。现在可以尝试在自己机器上运行下面的代码并理解其输出，\ndef outer():    fs = []    for i in range(4):  # i是整数类型 存在预留缓存池中        def inner():            print(&quot;i&quot;, id(i))            print(&quot;func&quot;, id(inner))  # 这里的inner的引用每次定义都会重新覆盖            return i        fs.append(inner)        inner()    print(&quot;*&quot; * 30)    for j in range(4):        # print(id(fs[j]), fs[j]())        print(fs[j](), id(fs[j]))          print(&quot;*&quot; * 30)    for i in range(4):        print(id(fs[i]), fs[i]())        print(&quot;*&quot; * 30)    return fsf1, f2, f3, f4 = outer()print(f1(), f2(), f3(), f4())\n\n装饰器先理解@的作用，然后再理解通常意义上的装饰器。\ndef funC():    print(&#x27;C&#x27;)def funA(arg):    print(&#x27;A&#x27;)    return funC@funAdef funB():    print(&#x27;B&#x27;)print(funB)\nfunA可以称为一个装饰器（通常意义上是装饰器应该写成一个闭包），它的特征是包含一个参数（这个参数会指向被修饰的函数对象，这里arg指向funB），返回一个函数对象（闭包形式中通常返回的是inner函数对象，这里返回了funC）；@funA的作用就是\nfunB = funA(funB)  # 以后调用funB(),就不是调用的你自己定义的funB函数了，它已经指向了装饰器返回的那个函数对象，也就是funC\n不是说能直接这样替换，我只是想意会一下@的作用，同时我希望你能注意到@funA不是定义或者加载，这里是真的跳转过去执行了一次funA，所以如果你在输出中看到了A，那么这个A是解释器在处理@funA时产生的，而不是在后面处理print(funB)时产生的。如果你对这些过程还有疑问，可以在各个位置添加print(id(函数名))来观察整个流程中的函数名指向的变化。下面通过一个比较简单的例子来解释我们为什么需要装饰器，并引出通常意义上的装饰器。假设你的同事定义了一系列函数，比如\ndef f(x):    return x + 1def g(x):    return x + 2\n你的老板说，“我希望每次调用一个函数都给我打印一下我调用的这个函数的名字，这样我们的程序变大变复杂了之后，我可以通过看输出知道我们的程序运行过程中调用了哪些函数，调用的次数和顺序，而不用去翻代码”，然后他把这个任务交给了你。最笨的方法当然是在每个函数的定义里加一句print(函数名.__name__)，（这里的__name__是函数对象的一个成员变量，其内容是函数名的字符串，这里的函数名是指def的时候用的那个名字，你可以在之前闭包代码的inner里加上这一句看看会打印出什么）,问题是你同事定义的那些函数又多又臭又长，你根本不想看，你也不能叫你同事去加，一方面现在只是加一行print代码比较简单，如果老板以后要求更复杂的功能呢，另一方面如果找同事去做就能解决问题，老板要你干嘛（另外有一个原则性问题，我们不应该轻易去修改已经写好的代码块，因为即使那些代码是你自己写的，一段时间之后，你也可能忘掉其中的一些逻辑细节，轻易修改会导致bug）。所以，这个时候最好的办法就是写一个装饰器：\ndef outer(fun):    def inner(b):        print(fun.__name__)        return fun(b)    return inner\n然后你只需要跟你的同事说，在他写的每一句def前面加一句@outer。例如\n@outerdef f(x):    return x + 1@outerdef g(x):    return x + 2print(f(1))\n这样调用f的时候，实际上是调用了f新指向的那个inner，而执行的时候fun就是被修饰前的那个f，就是同事def的那个函数，解释器会执行print(fun.__name__)（实现了老板要求你加的功能），然后执行return fun(b)（保留了你同事原来写的函数的功能），括号里的内容显示了这个叫装饰器的东西的优点。讲到这里，你已经基本理解了装饰器的概念、原理及优点。如果你上网查装饰器，你还会发现其他许多借助装饰器实现的骚操作，我这里只介绍了最简单的版本，但是你理解了我讲的这些之后，再去看那些更秀的操作，就不会一头雾水了。这里我在多讲一个内容，就是装饰器有其他参数的情况。你的公司100多个员工，每个人都写了一批函数，老板说，“我还希望调用一个函数的时候可以打印出这个函数是谁写的，这样出bug的时候，我可以知道该扣哪个人的工资”，你已经会写装饰器了，于是你轻松完成了这个任务，\ndef outer(name):    def mid(fun):        def inner(b):            print(name)            print(fun.__name__)            return fun(b)        return inner    return mid@outer(&#x27;szw&#x27;)def f(x):    return x + 1\n然后你和所有人说，在你们的函数前都加上@outer(&#39;你的名字&#39;)吧。现在我们用前面所学的所有知识来理解一下这个装饰器，以检测你是不是真的理解了前面的东西。乍一看这个装饰器写了三层函数，我刚看到的时候也是一脸懵逼，但是这实际上这并不是什么新规则，用我们前面讲的逻辑就能理解它了。正常的装饰标志是@outer这样的对吧，@后面应该写一个函数对象，而不是调用一个函数（参看前面说的关于fun和fun()的区别），那么@outer(&#39;szw&#39;)这里@后面为什么写了一个调用呢？对的，这里的确是调用了，所以你看看调用的返回值是什么，是一个函数对象mid，那这样就可以理解了——调用执行了outer(&#39;szw&#39;)后返回了一个和name=&#39;szw&#39;这个局部变量捆绑了的函数对象mid（参看前面讲的闭包的特性），然后执行@mid,再然后就和我们之前说的普通的装饰器的流程一样了。这个故事告诉我们，语言的特性（语法规则）能为程序员提供多大的便利是一回事，程序员能在规则之上写出怎样的骚操作就是另一个故事了，这取决于一个程序员灵活利用规则的造诣。而造诣=天分+努力，如果你不够聪明，就需要多看别人的代码，模仿并理解别人的骚操作。\n","tags":["python","algorithm"]},{"title":"猜数游戏","url":"/2018/03/16/%E7%8C%9C%E6%95%B0%E6%B8%B8%E6%88%8F/","content":"猜数游戏问题概述猜一个没有重复数字的四位数，每猜一次会反馈2个数字c和e，c表示你所猜的四位数中有几个数字在答案中出现，e表示出现的这几个数字有几个在四位数中的位置与答案一致（为了使得问题有良好的对称性，第四位是0的情况，即三位数，也是允许的）。要求写一个程序进行猜数，以尽可能少的次数猜到答案。\n思路设所有可能的数的集合为S，则答案是其中随机的一个元素。游戏的本质是根据反馈信息不断缩小S，直到找到答案。程序的任务就是根据已知信息（包括S的状态和反馈信息），作出猜哪个数的决策。因此，要提高猜数效率，有两点可以入手：1. 尽可能的利用反馈所带来的信息。不要浪费信息量，使得反馈所携带的所有信息都被程序用来减小集合S，即剔除不满足反馈信息的元素。方法是将集合中的每一个元素假设为答案，然后与你猜的数对比，如果计算出的反馈和实际得到的不同，说明该元素不是答案，换句话说，该元素已被反馈所携带的信息排除。每一次得到反馈后，都马上排除所有不符合信息的元素，即最大程度的利用了反馈信息。2. 每次猜可以最大程度削减S的那个数。当程序要决定应该猜哪个数时，对S中的每一个元素计算：猜该元素时，出现每种可能反馈时能排除的元素个数（程序中实际计算了能剩下的元素的个数）。然后比较所有元素削减S的程度。比较的方法有两个标准，对于每一个元素，取所有反馈对应剩下个数中最大值作为该猜元素后S还剩下多少的估计值（即最坏情况），另一种是取所有反馈情况的平均情况。使得S中元素剩下个数最少的那个数就是要猜的数。我的程序里两种标准都尝试了，并多次重复实验计算了平均猜数次数。神奇的是两种标准得到的平均次数是一样的，都是5.59左右。我觉得这个现象应该是可以理论证明的，但是我还没有想出来。先把疑问记录在这里，以后有了想法再补充吧。\nfrom random import randint as ridef feedback(num_a, num_b):    str_a = str(num_a)    str_b = str(num_b)    c = 0    e = 0    if len(str_a) == 3:        str_a = &quot;0&quot; + str_a    if len(str_b) == 3:        str_b = &quot;0&quot; + str_b    for i in range(4):        for j in range(4):            if str_a[i] == str_b[j]:                c += 1                if i == j:                    e += 1    return (c, e)def update_set(list_old, last, feed):    list_new = []    num = len(list_old)    for i in range(num):        if feedback(list_old[i], last) == feed:            list_new.append(list_old[i])    return list_newdef decision_1(list_new):    choise = 0    for n in list_new:        min_n = 10000        dict_f = &#123;&#125;        for m in list_new:            feed = feedback(n, m)            if feed not in dict_f:                dict_f[feed] = 1            else:                dict_f[feed] += 1        temp = sum(dict_f.values()) / len(dict_f)        if min_n &gt; temp:            min_n = temp            choise = n    return choisedef decision_2(list_new):    choise = 0    for n in list_new:        min_n = 10000        dict_f = &#123;&#125;        for m in list_new:            feed = feedback(n, m)            if feed not in dict_f:                dict_f[feed] = 1            else:                dict_f[feed] += 1        temp = max(dict_f.values())        if min_n &gt; temp:            min_n = temp            choise = n    return choiselist_ini = []  # 初始数据集for i1 in range(10):    for i2 in range(10):        if i1 == i2:            continue        for i3 in range(10):            if i3 == i1 or i3 == i2:                continue            for i4 in range(10):                if i4 == i1 or i4 == i2 or i4 == i3:                    continue                list_ini.append(i1 * 1000 + i2 * 100 + i3 * 10 + i4)n = 10 * 9 * 8 * 7sum_1 = 0sum_2 = 0t = 10000dict_choise = &#123;(0, 0): 9876, (1, 0): 9872, (1, 1): 9873, (2, 0): 9832, (2, 1): 9821, (2, 2): 9823, (3, 0): 9312, (3, 1): 9321, (3, 2): 9123, (3, 3): 9023, (4, 0): 3210, (4, 1): 3120, (4, 2): 3021, (4, 3): 0, (4, 4): 1023&#125;# dict_choise_2 = &#123;&#125;# for c in range(5):#     for e in range(c + 1):#         list_temp = update_set(list_ini, 1023, (c, e))#         choise_temp_1 = decision_1(list_temp)#         choise_temp_2 = decision_2(list_temp)#         dict_choise_1[(c, e)] = choise_temp_1#         dict_choise_2[(c, e)] = choise_temp_2# print(dict_choise_1)# print(dict_choise_2)for j in range(t):  # 循环测试,调整数字以控制测试次数    ans_index = ri(0, n - 1)  # 在初始数据集中随机取一个数字作为答案    ans = list_ini[ans_index]    # print(&quot;Case&quot;, j, &quot;:&quot;, ans)    # choise = 1023    i = 0    feed_ini = feedback(ans, 1023)    list_one = update_set(list_ini, 1023, feed_ini)    list_new = list_one    for i in range(1, 50):        if i == 1:            choise = dict_choise[feed_ini]        feed = feedback(ans, choise)        # print(choise, feed)        # c = int(input())        # e = int(input())        if feed[1] == 4:            # print(&quot;win!&quot;)            i += 1            break        # feed = (c, e)        list_new = update_set(list_new, choise, feed)        choise = decision_1(list_new)    sum_1 += i    # choise = 1023    list_new = list_one    i = 0    for i in range(1, 50):        if i == 1:            choise = dict_choise[feed_ini]        feed = feedback(ans, choise)        # print(choise, feed)        # c = int(input())        # e = int(input())        if feed[1] == 4:            # print(&quot;win!&quot;)            i += 1            break        # feed = (c, e)        list_new = update_set(list_new, choise, feed)        choise = decision_2(list_new)    sum_2 += i    print(j)print(sum_1 / t)print(sum_2 / t)# if i == 20:# print(&quot;fail!&quot;)# else:# print(&quot;tried&quot;, i, &quot;times\\n&quot;)","tags":["python","algorithm"]}]